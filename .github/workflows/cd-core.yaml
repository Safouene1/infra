name: cd / core

on:
  push:
    branches:
      - main
    tags:
      - v*
    paths:
      - go.mod
      - go.sum
      - '**/*.go'

jobs:
  release-name:
    runs-on: ubuntu-latest
    outputs:
      release-name: ${{ steps.release-name.outputs.release-name }}
    steps:
      - uses: actions/checkout@v3
      - id: release-name
        run: |
          RELEASE_NAME=${{ startsWith(github.ref, 'refs/tags/') && github.ref_name || '$(git describe --tags)' }}
          echo "::set-output name=release-name::${RELEASE_NAME#v}"

  build:
    runs-on: ubuntu-latest
    needs: [release-name]
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-go@v3
        with:
          go-version: 1.18
          cache: true
      - uses: goreleaser/goreleaser-action@v3
        with:
          distribution: goreleaser
          version: latest
          args: release --rm-dist --skip-publish --snapshot
        env:
          RELEASE_NAME: ${{ needs.release-name.outputs.release-name }}
      - uses: actions/upload-artifact@v3
        with:
          name: binaries
          path: dist/

  publish:
    runs-on: ubuntu-latest
    needs: [release-name, build]
    if: ${{ startsWith(github.ref, 'refs/tags/') }}
    steps:
      - uses: actions/download-artifact@v3
        with:
          name: binaries
      - run: |
          # fail fast if the release does not exist
          gh release view v${{ needs.release-name.outputs.release-name }} || exit 1
          gh release upload v${{ needs.release-name.outputs.release-name }} *.txt *.zip *.deb *.rpm
        env:
          GH_TOKEN: ${{ github.token }}
      - run: aws s3 sync . s3://release.infrahq.com/infra/v${{ needs.release-name.outputs.release-name }} --exclude '*' --include '*.zip' --include '*.deb' --include '*.rpm' --include 'infra-checksums.txt' --acl public-read
      - run: |
          for PACKAGE in *.deb *.rpm; do
            curl -fsSL -F package=@$PACKAGE https://${{ secrets.GEMFURY_TOKEN }}@push.fury.io/infrahq/
          done

  update-repos:
    runs-on: ubuntu-latest
    needs: [release-name, publish]
    if: ${{ startsWith(github.ref, 'refs/tags/') }}
    strategy:
      matrix:
        repos:
          - repo: infrahq/homebrew-tap
            script: update-tap.sh
            commit-prefix: "Homebrew tap"
          - repo: infrahq/scoop
            script: update-scoop.sh
            commit-prefix: "Scoop"
    steps:
      - uses: actions/checkout@v3
        with:
          repository: ${{ matrix.repos.repo }}
          token: ${{ secrets.GORELEASER_GITHUB_TOKEN }}
      - run: |
          git config --global user.name infrahq-ci
          git config --global user.email contact@infrahq.com
          sh ${{ matrix.repos.script }} ${{ needs.release-name.outputs.release-name }}
          PACKAGE=$(git status --porcelain | awk '{ print $2 }')
          git add $PACKAGE
          git commit -m "${{ matrix.repos.commit-prefix }} update for ${PACKAGE%.*} version ${{ needs.release-name.outputs.release-name }}"
          git push origin @:refs/heads/main

  docker:
    runs-on: ubuntu-latest
    needs: [release-name]
    env:
      IMAGE: infrahq/infra
      CONTEXT: .
    steps:
      - uses: actions/checkout@v3
      - uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}
      - id: metadata
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.IMAGE }}
          tags: |
            type=semver,pattern={{version}}
            type=sha,prefix=
            type=edge
      - uses: docker/setup-buildx-action@v2
      - uses: docker/setup-qemu-action@v2
      - uses: docker/build-push-action@v3
        with:
          context: ${{ env.CONTEXT }}
          push: true
          platforms: linux/amd64,linux/arm64
          build-args: |
            BUILDVERSION=${{ needs.release-name.outputs.release-name }}
            TELEMETRY_WRITE_KEY=${{ secrets.TELEMETRY_WRITE_KEY }}
          tags: ${{ steps.metadata.outputs.tags }}
          labels: ${{ steps.metadata.outputs.labels }}
          cache-from: type=registry,ref=${{ env.IMAGE }}:latest
          cache-to: type=inline
